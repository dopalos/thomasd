package rpc

import (

    "encoding/hex"
    "encoding/json"
    "io"
    "log"
    "net/http"
    "runtime/pprof"
    "strconv"
    "strings"
    "time"

    "thomasd/internal/app"
    "thomasd/internal/codec"
    "thomasd/internal/tx"
)

const (
    feeBPS          = 10 // 0.1%
    allowedChainID  = "thomas-dev-1"
    masPerTHO       = 10_000_000
    masPerMicro     = 10
    maxMsgCommitLen = 64
)

func NewRouter(eng *app.Engine) http.Handler {
    mux := http.NewServeMux()

    // --- Debug: echo ---
    mux.HandleFunc("/debug/echo", func(w http.ResponseWriter, r *http.Request) {
        b, _ := io.ReadAll(r.Body)
        w.Header().Set("Content-Type", "application/octet-stream")
        w.Write(b)
    })

    // --- Debug: stack dump ---
    mux.HandleFunc("/debug/stack", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        w.Header().Set("Content-Type", "text/plain; charset=utf-8")
        _ = pprof.Lookup("goroutine").WriteTo(w, 2)
    })

    // --- Health ---
    mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]string{
            "status":   "ok",
            "time_utc": time.Now().UTC().Format(time.RFC3339),
        })
    })

    // --- SSE ---
    mux.HandleFunc("/events/stream", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        fl, ok := w.(http.Flusher)
        if !ok {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")

        ch := eng.SubscribeForSSE()
        defer eng.UnsubscribeForSSE(ch)

        notify := r.Context().Done()
        for {
            select {
            case <-notify:
                return
            case msg := <-ch:
                w.Write([]byte("event: push\n"))
                w.Write([]byte("data: "))
                w.Write(msg)
                w.Write([]byte("\n\n"))
                fl.Flush()
            }
        }
    })

    // --- Node info ---
    mux.HandleFunc("/node/info", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "algo":       "ed25519",
            "pubkey_hex": eng.PubKeyHex(),
        })
    })

    // --- Height ---
    mux.HandleFunc("/height", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        h := eng.CurrentHeight()
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{"height": h})
    })

    // --- Policy ---
    mux.HandleFunc("/policy", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "unit":               "mas",
            "fee_bps":            feeBPS,
            "min_fee_mas":        1,
            "max_msg_commit_len": maxMsgCommitLen,
            "allowed_chain_id":   allowedChainID,
            "expiry_rule":        "valid if expiry_height==0 OR current_height < expiry_height",
            "signing": map[string]any{
                "algo":             "ed25519",
                "pubkey_hex":       eng.PubKeyHex(),
                "header_canonical": []string{"round", "from_height", "to_height", "tx_count", "root", "time_utc"},
            },
        })
    })

    // --- Account ---
    mux.HandleFunc("/account/", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        addr := strings.TrimPrefix(r.URL.Path, "/account/")
        a := eng.GetAccount(addr)
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "balance_mas": a.Balance,
            "balance":     a.Balance / masPerMicro,
            "nonce":       a.Nonce,
            "unit":        "mas",
        })
    })

    // --- Nonce ---
    mux.HandleFunc("/nonce/", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        addr := strings.TrimPrefix(r.URL.Path, "/nonce/")
        acc := eng.GetAccount(addr)
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "nonce": acc.Nonce, "expected_nonce": acc.Nonce + 1,
        })
    })

    // --- Merkle ---
    mux.HandleFunc("/merkle", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        root := eng.MerkleRoot()
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "root":  hex.EncodeToString(root),
            "count": eng.ReceiptCount(),
        })
    })

    // --- TX 조회: GET /tx/{hash} ---
    mux.HandleFunc("/tx/", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        h := strings.TrimPrefix(r.URL.Path, "/tx/")
        w.Header().Set("Content-Type", "application/json")
        if h == "" {
            w.WriteHeader(http.StatusBadRequest)
            _ = json.NewEncoder(w).Encode(map[string]string{"error": "bad_hash"})
            return
        }
        rec, ok := eng.GetReceipt(h)
        if !ok {
            w.WriteHeader(http.StatusNotFound)
            _ = json.NewEncoder(w).Encode(map[string]string{"error": "not_found"})
            return
        }
        _ = json.NewEncoder(w).Encode(rec)
    })

    // --- Supply snapshot ---
    mux.HandleFunc("/supply/current", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        aF := eng.GetAccount("tho1foundation")
        aX := eng.GetAccount("tho1exchange")
        aA := eng.GetAccount("tho1alice")
        aB := eng.GetAccount("tho1bob")
        totalMas := aA.Balance + aB.Balance + aF.Balance + aX.Balance
        format := func(m uint64) map[string]any {
            return map[string]any{
                "tho":       m / masPerTHO,
                "mas":       m % masPerTHO,
                "mas_total": m,
                "display":   strconv.FormatUint(m/masPerTHO, 10) + " THO " + strconv.FormatUint(m%masPerTHO, 10) + " mas",
            }
        }
        network := totalMas - aF.Balance - aX.Balance
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "unit":       "mas",
            "foundation": format(aF.Balance),
            "exchange":   format(aX.Balance),
            "network":    format(network),
            "total":      format(totalMas),
        })
    })

    // --- Minting (라이트) ---
    mux.HandleFunc("/minting", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        aF := eng.GetAccount("tho1foundation")
        aX := eng.GetAccount("tho1exchange")
        aA := eng.GetAccount("tho1alice")
        aB := eng.GetAccount("tho1bob")
        totalMas := aA.Balance + aB.Balance + aF.Balance + aX.Balance
        format := func(m uint64) map[string]any {
            return map[string]any{
                "tho":       m / masPerTHO,
                "mas":       m % masPerTHO,
                "mas_total": m,
                "display":   strconv.FormatUint(m/masPerTHO, 10) + " THO " + strconv.FormatUint(m%masPerTHO, 10) + " mas",
            }
        }
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "basis":      "E_net",
            "epoch":      0,
            "foundation": format(aF.Balance),
            "exchange":   format(aX.Balance),
            "network":    format(totalMas - aF.Balance - aX.Balance),
            "total":      format(totalMas),
        })
    })

    // --- Rounds ---
    mux.HandleFunc("/round/commit", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        hdr, ok := eng.CommitRound()
        w.Header().Set("Content-Type", "application/json")
        if !ok {
            _ = json.NewEncoder(w).Encode(map[string]any{"committed": false, "reason": "no_pending"})
            return
        }
        _ = json.NewEncoder(w).Encode(map[string]any{"committed": true, "header": hdr})
    })
    mux.HandleFunc("/round/latest", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        hdr, ok := eng.LatestRound()
        w.Header().Set("Content-Type", "application/json")
        if !ok {
            w.WriteHeader(http.StatusNotFound)
            _ = json.NewEncoder(w).Encode(map[string]string{"error": "no_round"})
            return
        }
        _ = json.NewEncoder(w).Encode(hdr)
    })
    mux.HandleFunc("/round/", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        rest := strings.TrimPrefix(r.URL.Path, "/round/")

        if strings.HasSuffix(rest, "/header") {
            numStr := strings.TrimSuffix(rest, "/header")
            n64, err := strconv.ParseUint(numStr, 10, 64)
            if err != nil || n64 == 0 {
                w.WriteHeader(http.StatusBadRequest)
                _ = json.NewEncoder(w).Encode(map[string]string{"error": "bad_round"})
                return
            }
            hdr, ok := eng.GetRound(n64)
            w.Header().Set("Content-Type", "application/json")
            if !ok {
                w.WriteHeader(http.StatusNotFound)
                _ = json.NewEncoder(w).Encode(map[string]string{"error": "not_found"})
                return
            }
            _ = json.NewEncoder(w).Encode(hdr)
            return
        }

        if strings.HasSuffix(rest, "/signed") {
            numStr := strings.TrimSuffix(rest, "/signed")
            n64, err := strconv.ParseUint(numStr, 10, 64)
            if err != nil || n64 == 0 {
                w.WriteHeader(http.StatusBadRequest)
                _ = json.NewEncoder(w).Encode(map[string]string{"error": "bad_round"})
                return
            }
            hdr, ok := eng.GetRound(n64)
            w.Header().Set("Content-Type", "application/json")
            if !ok {
                w.WriteHeader(http.StatusNotFound)
                _ = json.NewEncoder(w).Encode(map[string]string{"error": "not_found"})
                return
            }
            sigHex := hdr.SignatureHex
            if sigHex == "" {
                if sig, ok2 := eng.SignRoundHeader(hdr); ok2 {
                    sigHex = hex.EncodeToString(sig)
                }
            }
            _ = json.NewEncoder(w).Encode(map[string]any{
                "header":        hdr,
                "algo":          "ed25519",
                "pubkey_hex":    eng.PubKeyHex(),
                "signature_hex": sigHex,
            })
            return
        }

        w.WriteHeader(http.StatusNotFound)
    })
    mux.HandleFunc("/round/latest/signed", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        hdr, ok := eng.LatestRound()
        w.Header().Set("Content-Type", "application/json")
        if !ok {
            w.WriteHeader(http.StatusNotFound)
            _ = json.NewEncoder(w).Encode(map[string]string{"error": "no_round"})
            return
        }
        sigHex := hdr.SignatureHex
        if sigHex == "" {
            if sig, ok2 := eng.SignRoundHeader(hdr); ok2 {
                sigHex = hex.EncodeToString(sig)
            }
        }
        _ = json.NewEncoder(w).Encode(map[string]any{
            "header":        hdr,
            "algo":          "ed25519",
            "pubkey_hex":    eng.PubKeyHex(),
            "signature_hex": sigHex,
        })
    })

    // --- TX 제출: POST /tx ---
    mux.HandleFunc("/tx", func(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        w.WriteHeader(http.StatusMethodNotAllowed)
        return
    }

    // 디버그 숏컷
    if r.URL.Query().Get("debug") == "ping" {
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{"status": "ok", "reason": "ping"})
        return
    }

    b, _ := io.ReadAll(r.Body)
    ct := strings.ToLower(r.Header.Get("Content-Type"))
    if strings.Contains(r.URL.RawQuery, "debuglog=1") { log.Printf("/tx recv ct=%q len=%d", ct, len(b)) }// 디버그: 파싱 스킵 (절대 블로킹 금지)
    if r.URL.Query().Get("debug") == "skipapply" {
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "status":  "queued",
            "parsed":  false,
            "ok":      true,
            "applied": false,
            "reason":  "skipapply",
            "len":     len(b),
            "ct":      ct,
        })
        return
    }

    var t tx.Transfer
    var parseErr error
    switch {
    case strings.HasPrefix(ct, "application/cbor"):
        parseErr = codec.DecodeCBOR(b, &t)
    case strings.HasPrefix(ct, "application/json"), len(b) > 0 && (b[0] == '{' || b[0] == '['):
        parseErr = codec.DecodeJSON(b, &t)
    default:
        parseErr = io.EOF
    }

    w.Header().Set("Content-Type", "application/json")
    if parseErr != nil {
        _ = json.NewEncoder(w).Encode(map[string]any{"status": "queued", "parsed": false, "error": parseErr.Error()})
        return
    }

    ok := t.Type == 1 && t.AmountMas > 0
    reason := ""

    // 체인ID
    if t.ChainID != allowedChainID {
        ok = false
        reason = "bad_chain_id"
    }

    // 수수료(0.1%, 최소 1 mas)
    expFeeMas := (t.AmountMas * feeBPS) / 10000
    if expFeeMas < 1 {
        expFeeMas = 1
    }
    if t.FeeMas != expFeeMas {
        ok = false
        if reason == "" {
            reason = "bad_fee"
        }
    }

    // msg_commitment 길이
    if len(t.MsgCommit) > maxMsgCommitLen {
        ok = false
        if reason == "" {
            reason = "msg_commitment_too_large"
        }
    }

    // 만료
    curH := eng.CurrentHeight()
    if t.ExpiryHeight > 0 && curH >= t.ExpiryHeight {
        ok = false
        if reason == "" {
            reason = "expired"
        }
    }

    // 타입/금액 0 체크
    if t.Type != 1 {
        ok = false
        if reason == "" {
            reason = "bad_type"
        }
    }
    if t.AmountMas == 0 {
        ok = false
        if reason == "" {
            reason = "zero_amount"
        }
    }

    // 논스 힌트
    fromAcc := eng.GetAccount(t.From)
    currentNonce := fromAcc.Nonce
    expectedNonce := currentNonce + 1

    applied := false
    if ok {
        if err := eng.ApplyTransfer(t); err != nil {
            reason = "apply:" + err.Error()
        } else {
            applied = true
        }
    }

    rec := eng.StoreReceipt(t, applied, reason)

    _ = json.NewEncoder(w).Encode(map[string]any{
        "status": "queued", "parsed": true, "ok": ok, "applied": applied, "reason": reason,
        "tx_hash": rec.TxHash, "from": rec.From, "to": rec.To,
        "amount_mas": rec.Amount, "fee_mas": rec.Fee,
        "amount": rec.Amount / masPerMicro, "fee": rec.Fee / masPerMicro,
        "nonce": rec.Nonce, "height": rec.Height, "time_utc": rec.TimeUTC,
        "current_nonce": currentNonce, "expected_nonce": expectedNonce,
        "expected_fee_mas": expFeeMas, "root_deferred": true,
        "receipts_count":   eng.ReceiptCount(),
    })
    })

    
    // GET /stats : 러닝 상태 요약
    mux.HandleFunc("/stats", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        w.Header().Set("Content-Type","application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "height":         eng.CurrentHeight(),
            "receipts_count": eng.ReceiptCount(),
            "time_utc":       time.Now().UTC().Format(time.RFC3339),
        })
    })

    // === AUTO-PATCH: /stats(JSON), /stats.json ===
    mux.HandleFunc("/stats", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet { w.WriteHeader(http.StatusMethodNotAllowed); return }
        w.Header().Set("Content-Type","application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "height":         eng.CurrentHeight(),
            "receipts_count": eng.ReceiptCount(),
            "time_utc":       time.Now().UTC().Format(time.RFC3339),
        })
    })
    mux.HandleFunc("/stats.json", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet { w.WriteHeader(http.StatusMethodNotAllowed); return }
        w.Header().Set("Content-Type","application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
            "height":         eng.CurrentHeight(),
            "receipts_count": eng.ReceiptCount(),
            "time_utc":       time.Now().UTC().Format(time.RFC3339),
        })
    })
return mux
}

// (옵션) SSE용 인터페이스
type sseAdapter interface {
    SubscribeForSSE() chan []byte
    UnsubscribeForSSE(ch chan []byte)
}




